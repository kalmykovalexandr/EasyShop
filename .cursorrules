# EasyShop Project Rules

## CRITICAL - Mandatory Rules
- **ALWAYS ask for permission before modifying any file**
- **Explain the reason for each change before executing it**
- Never create files without explicit user permission
- Testing after each concluded operation
- If classes are unsued -> remove them

## General Working Principles
- Use descriptive file names in lowercase
- Follow consistent naming standards
- Always explain the logic behind proposed changes

## Project Architecture
- Microservices architecture with Spring Boot
- API Gateway for routing
- Separate services: auth-service, product-service, purchase-service
- React frontend with Vite
- Docker containerization
- PostgreSQL databases

## Backend (Java/Spring Boot)
- Use Spring Boot 3.x
- Follow REST API principles
- Use JPA/Hibernate for database operations
- Apply Flyway for database migrations
- Use Maven for dependency management
- Follow SOLID and Clean Architecture principles
- Use Spring annotations (@RestController, @Service, @Repository)
- Apply validation with @Valid and @Validated
- Use ResponseEntity for HTTP responses

## Frontend (React/Vite)
- Use functional components with hooks
- Apply Context API for state management
- Use React Router for navigation
- Follow component architecture principles
- Use CSS modules or styled-components
- Apply TypeScript for typing (if used)
- Use Vite for build and development

## Database
- Use PostgreSQL
- Create migrations with Flyway
- Follow table naming conventions (snake_case)
- Use indexes for query optimization
- Apply foreign keys for table relationships

## Docker and Infrastructure
- Create separate Dockerfile for each service
- Use docker-compose for local development
- Apply multi-stage builds for image optimization
- Use .dockerignore to exclude unnecessary files

## Security
- Use JWT tokens for authentication
- Apply CORS settings
- Validate all incoming data
- Use HTTPS in production
- Apply principle of least privilege

## Testing
- Write unit tests for business logic
- Create integration tests for API
- Use Mockito for dependency mocking
- Apply TestContainers for database testing

## Code Style
- Use 4 spaces for indentation in Java
- Use 2 spaces for indentation in JavaScript/TypeScript
- Follow Java Code Conventions
- Use ESLint and Prettier for frontend
- Apply Checkstyle for Java code

## Git and Versioning
- Use conventional commits
- Create feature branches for new functionality
- Write descriptive commit messages
- Use pull requests for code review

## Documentation
- Write JavaDoc for public methods
- Create README files for each service
- Document API with OpenAPI/Swagger
- Update documentation when code changes

## Performance
- Use caching where appropriate
- Optimize SQL queries
- Apply lazy loading for JPA
- Use connection pooling
- Monitor application performance

## Logging
- Use SLF4J with Logback
- Apply structured logging (JSON)
- Use different logging levels (DEBUG, INFO, WARN, ERROR)
- Do not log sensitive information

## Error Handling
- Use global exception handlers
- Create custom exceptions
- Return clear error messages
- Log errors with context

## Configuration
- Use application.yml for configuration
- Apply profiles for different environments
- Use external configuration files
- Do not hardcode configuration values

## Monitoring and Metrics
- Use Spring Boot Actuator
- Apply Micrometer for metrics
- Configure health checks
- Monitor performance and availability
